import { PubSub } from '@google-cloud/pubsub';
import httpMocks from 'node-mocks-http';
import { NextFunction } from 'express';
import { transaction, Model, Transaction } from 'objection';
import sinon from 'sinon';
import { API_VERSION } from '../../app';
import { signPayload, stringifyMessage } from '../../middleware/publish-member-to-pubsub';
import { Member } from '../../models/member';
import { MemberInsurance } from '../../models/member-insurance';
import { MemberDemographics } from '../../models/member-demographics';
import { createAndPublishMember } from '../create-member-and-publish';
import { createAndPublishMemberRequest, memberPubSubMessage } from './test-data';
import { setupDb } from './test-setup';

const sandbox = sinon.createSandbox();
describe('Create and Publish member route', () => {
  let txn: Transaction;
  let testDb: ReturnType<typeof setupDb>;
  const clientSource = 'testSource';

  const testTopicName = 'testTopicName';
  const testHmacSecret = 'JNLVwA7WXHHUfv4ZArPjRDJE';
  const testPubsub = new PubSub({});
  let publishStub;
  let topicStub;

  beforeAll(async () => {
    testDb = setupDb();
  });

  afterAll(async () => testDb.destroy());

  describe('on success', () => {
    beforeEach(async () => {
      jest.spyOn(console, 'error').mockImplementation(() => null);
      txn = await transaction.start(Model.knex());

      jest.spyOn(console, 'error').mockImplementation(() => undefined);
      publishStub = sandbox.stub().returns('testMessageId');
      topicStub = sandbox.stub(testPubsub, 'topic').returns({ publish: publishStub });
    });

    afterEach(async () => {
      await txn.rollback();
      sandbox.restore();
    });

    it('should successfully create a member and publish them using demographic info', async () => {
      const next = jest.fn() as NextFunction;
      const response = httpMocks.createResponse();
      const request = httpMocks.createRequest({
        method: 'POST',
        url: `/${API_VERSION}/members/createAndPublish`,
        body: createAndPublishMemberRequest,
        headers: { clientSource },
      });

      request.hmacSecret = testHmacSecret;
      request.topicName = testTopicName;
      request.pubsub = testPubsub;

      request.txn = txn;

      await createAndPublishMember(request, response, next);

      const { patientId, cityblockId, mrn, messageId } = response._getData();
      const savedMember = await Member.get(patientId, txn);
      const savedClientSource = await Member.query(txn)
        .select(['clientSource'])
        .where({ id: patientId })
        .first();

      // Verify that the response information is correct
      expect(cityblockId).toBe(savedMember.cbhId);
      expect(messageId).toBeDefined();
      expect(response.statusCode).toBe(200);
      expect(clientSource).toBe(savedClientSource.clientSource);
      expect(mrn).toBeNull();

      // Stub the patientId and cityblockId since those are randomly generated by the database
      const testData = stringifyMessage(memberPubSubMessage(patientId, cityblockId, mrn));
      const msgAttributes = { hmac: signPayload(testData, testHmacSecret), topic: undefined };

      // Verify that the pubsub message sent to commons matches our expected message to be sent
      sandbox.assert.calledOnceWithExactly(topicStub, testTopicName);
      sandbox.assert.calledOnceWithExactly(publishStub, Buffer.from(testData), msgAttributes);

      const memberDemographics = await MemberDemographics.getByMemberId(patientId, txn);

      expect(memberDemographics.firstName).toBe('Perry');
      expect(memberDemographics.lastName).toBe('Platypus');
      expect(memberDemographics.dateOfBirth).toBe('1980-01-01');
      expect(memberDemographics.sex).toBe('male');

      expect(memberDemographics.phones).toEqual(
        expect.arrayContaining([expect.objectContaining({ phone: '213-234-1635' })])
      );
      expect(memberDemographics.emails).toEqual(
        expect.arrayContaining([expect.objectContaining({ email: 'terry@gmail.com' })])
      );
      expect(memberDemographics.addresses).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            street1: '1 Main Street',
            street2: 'Apartment 1',
            city: 'Winterfell',
            state: 'The North',
            zip: '11111',
          })
        ])
      );

      const memberInsurances = await MemberInsurance.getByMember(patientId, txn);

      const expectedInsurances = [
        {
          carrier: "emblem", 
          plans: [
            { 
              externalId: "8435092485904285",
              current: true,
              rank: 'primary',
              details: [{ 
                id: expect.any(String), 
                lineOfBusiness: "medicare",
                subLineOfBusiness: "dual",
                spanDateEnd: null,
                spanDateStart: null
              }]
            }
          ]
        },
        { carrier: "medicaidNY", plans: [{ current: null, details: [], externalId: "12", rank: null }] },
        { carrier: "medicareNY", plans: [{ current: null, details: [], externalId: "21", rank: null }] }
      ];

      expect(memberInsurances).toMatchObject(expectedInsurances);
    });
  });
});
